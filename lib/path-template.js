const PathTemplate = exports;

MissingVariableError = function (message) {
  this.name = "MissingVariableError";
  this.message = message || "variable not defined";
};
MissingVariableError.prototype = new Error();
MissingVariableError.prototype.constructor = MissingVariableError;
PathTemplate.MissingVariableError = MissingVariableError;

const SLASH = ["string", "/"];
const DOT = ["string", "."];

const tokenize = function (string) {
  return string.split(/([\/:*.)(])/).filter(function (x) {
    return x;
  });
};

const lex = function (tokens) {
  let parts = [],
    i,
    tokensLength = tokens.length,
    token,
    optionalPartsConsumed,
    optionalParts;
  for (i = 0; i < tokensLength; i += 1) {
    token = tokens[i];
    if (token === "/") {
      parts.push(["string", token]);
    } else if (token === ":") {
      parts.push(["variable", tokens[i += 1]]);
    } else if (token === "*") {
      token = tokens[i += 1];
      if (token === "/" || token === ".") {
        i -= 1;
        token = null;
      }
      parts.push(["splat", token]);
    } else if (token === "(") {
      optionalPartsConsumed = lex(tokens.slice(i + 1));
      optionalParts = optionalPartsConsumed[0];
      parts.push(["option", optionalParts.length]);
      parts = parts.concat(optionalParts);
      i += optionalPartsConsumed[1] + 1;
    } else if (token === ")") {
      break;
    } else {
      parts.push(["string", token]);
    }
  }
  return [parts, i];
};

/**
 * Returns a compiled path template, generated from the given string.
 *
 * @example
 * let template = PathTemplate.parse("/users/:userID");
 *
 * @param {string} string A URL path template
 * @returns {PathTemplate} A compiled path template
 */
PathTemplate.parse = function (string) {
  const partsConsumed = lex(tokenize(string));
  return partsConsumed[0];
};

/**
 * Returns the string representation of a compiled path template.
 *
 * @example
 * console.log(PathTemplate.inspect(template));
 *
 * @param {PathTemplate} template A compiled path template
 * @returns {string} the string representation of template
 */
PathTemplate.inspect = function recursiveInspect(template) {
  if (template.length === 0) {
    return "";
  }

  let head = template.slice(0, 1)[0],
    value = head[1],
    tail = template.slice(1),
    out;

  switch (head[0]) {
  case "variable":
    out = ":" + value;
    break;
  case "splat":
    out = value ? "*" + value : "*";
    break;
  case "option":
    out = "(" + recursiveInspect(tail.slice(0, value)) + ")";
    tail = tail.slice(value);
    break;
  default:
    out = value;
  }

  return out + recursiveInspect(tail);
};

/**
 * Returns the variable names (including splats/globs) used in a path template.
 *
 * @example
 * let keys = PathTemplate.variables(template);
 *
 * @param {PathTemplate} template A compiled path template
 * @returns {Array} the variable names used in template
 */
PathTemplate.variables = function (template) {
  let acc = [],
    templateLength = template.length,
    part,
    type,
    val;
  for (let i = 0; i < templateLength; i += 1) {
    part = template[i];
    type = part[0];
    val = part[1];
    if (type === "variable") {
      acc.push(val);
    } else if (type === "splat" && val) {
      acc.push(val);
    }
  }
  return acc;
};

/**
 * Returns a URL path generated by substituting the variables in template with
 * the values of the correspondingly named properties in an object.
 *
 * @example
 * let url = PathTemplate.format(template, {userID: 1});
 *
 * @param {PathTemplate} template A compiled path template
 * @param {Object} obj An object with properties corresponding with the
 *                     variables in template
 * @returns {string} the URL path generated from combining template and obj.
 */
PathTemplate.format = function recursiveFormat(template, obj, throwOnMissing) {
  if (template.length === 0) {
    return "";
  }

  let head = template.slice(0, 1)[0],
    value = head[1],
    tail = template.slice(1),
    out = "",
    referencedValue,
    rest;

  switch (head[0]) {
  case "string":
    out = value;
    break;
  case "variable":
    referencedValue = obj[value];
    if (typeof referencedValue !== "undefined") {
      out = referencedValue;
    } else if (throwOnMissing) {
      throw new MissingVariableError(value + " is not defined");
    }
    break;
  case "splat":
    referencedValue = obj[value];
    if (Array.isArray(referencedValue)) {
      out = referencedValue.join("/");
    } else if (typeof referencedValue !== "undefined") {
      out = referencedValue;
    }
    break;
  case "option":
    try {
      out = recursiveFormat(tail.slice(0, value), obj, true);
    } catch (e) {
      if (!(e instanceof MissingVariableError)) {
        throw e;
      }
    }
    tail = tail.slice(value);
    break;
  }

  rest = recursiveFormat(tail, obj, throwOnMissing);
  if (out === "/" && rest[0] === "/") {
    return rest;
  }
  return out + rest;
};

const matcherFinished = function(matcher) {
  let i = matcher.index,
    max = matcher.template.length,
    current;
  if (i < max) {
    while (i < max) {
      current = matcher.template[i];
      if (current[0] === "splat") {
        i += 1;
      } else if (current[0] === "option") {
        i += (1 + current[1]);
      } else {
        return false;
      }
    }
  }
  return true;
};

const copyCaptures = function(captures) {
  const copy = Object.create({});
  for (const prop in captures) {
    if (captures.hasOwnProperty(prop)) {
      copy[prop] = captures[prop];
    }
  }
  return copy;
};

const matcherAdvancers = {
  string: function (matcher, string, value) {
    if (string === value) {
      return [{template: matcher.template, index: matcher.index + 1,
        captures: matcher.captures}];
    }
  },

  variable: function (matcher, string, value) {
    const captures = copyCaptures(matcher.captures);
    captures[value] = string;
    return [{template: matcher.template, index: matcher.index + 1,
      captures: captures}];
  },

  splat: function (matcher, string, value) {
    let captures = copyCaptures(matcher.captures),
      matchNext,
      newMatcher;

    if (value && !captures[value]) {
      captures[value] = [];
    }

    // try the next part of the template to see if the splat has ended
    matchNext = advanceMatcher({template: matcher.template,
      index: matcher.index + 1, captures: captures}, string);

    // if the next didn't match and it's a slash, try skipping it
    // this is meant for zero width splats, e.g. /foo/*/bar match /foo/bar
    if (!matchNext && arrayEql(matcher.template[matcher.index + 1], SLASH)){
      matchNext = advanceMatcher({template: matcher.template,
        index: matcher.index + 2, captures: captures}, string);
    }

    if (matchNext) {
      captures = copyCaptures(captures);
    }

    if (string !== "/" && value) {
      captures[value] = captures[value].concat(string);
    }

    newMatcher = {template: matcher.template, index: matcher.index,
      captures: captures};
    if (matchNext) {
      return matchNext.concat(newMatcher);
    }
    return [newMatcher];
  },

  option: function (matcher, string, value) {
    let captures = copyCaptures(matcher.captures),
      matchers = [],
      matchNext,
      matchAhead;

    matchNext = advanceMatcher({template: matcher.template,
      index: matcher.index + 1, captures: captures}, string);

    if (matchNext) {
      captures = copyCaptures(captures);
      matchers = matchers.concat(matchNext);
    }

    matchAhead = advanceMatcher({template: matcher.template,
      index: matcher.index + 1 + value, captures: captures}, string);

    if (matchAhead) {
      matchers = matchers.concat(matchAhead);
    }

    return matchers;
  }
};

const advanceMatcher = function(matcher, string) {
  const part = matcher.template[matcher.index];
  if (part && part[0]) {
    return matcherAdvancers[part[0]](matcher, string, part[1]);
  }
};

const flattenCompact = function (array) {
  return array.reduce(function (acc, ary) {
    if (ary) {
      acc = acc.concat(ary);
    }
    return acc;
  }, []);
};

const outputCaptures = function (captures, template) {
  const last = template.slice(-1)[0],
    val = last[1];
  captures = copyCaptures(captures);
  if (last[0] === "splat" && val && typeof captures[val] === "undefined") {
    captures[val] = [];
  }
  return captures;
};

/**
 * If string is a path matching the format of template, returns a match object
 * containing the parameters found in the path, otherwise returns undefined.
 *
 * @example
 * let match = PathTemplate.match(templates, url.pathname);
 *
 * @param {PathTemplate} template A compiled path template
 * @param {string} template A URL path to match against
 * @returns {Object|undefined} the values of the variables used in the matched
 *                             template, or undefined if none match
 */
PathTemplate.match = function (template, string) {
    let matchers = [{template: template, index: 0, captures: {}}];
    const parts = tokenize(string);

  for (let i = 0; i < parts.length; i += 1) {
    matchers = flattenCompact(matchers.map((m) => advanceMatcher(m, parts[i])));
    if (matchers.length === 0) {
      return;
    }
  }
  for (let i = 0; i < matchers.length; i += 1) {
    const matcher = matchers[i];
    if (matcherFinished(matcher)) {
      return outputCaptures(matcher.captures, matcher.template);
    }
  }
};

const arrayEql = function (a, b) {
  return a && b && !(a < b || a > b);
};

const addTemplate = function (template, other) {
  if (other.length === 0) {
    return template.slice();
  }
  const tLast = template[template.length - 1],
    oFirst = other[0];
  if (arrayEql(tLast, oFirst) && arrayEql(tLast, SLASH)) {
    other = other.slice(1);
  } else if (!(arrayEql(tLast, SLASH) || arrayEql(oFirst, SLASH) ||
    arrayEql(tLast, DOT) || arrayEql(oFirst, DOT))) {
    other = [SLASH].concat(other);
  }
  return template.concat(other);
};

/**
 * Returns a new path template by appending the path described by string.
 *
 * @example
 * let photoTemplate = PathTemplate.add(template, "/photos/:photoID");
 *
 * @param {PathTemplate} template A compiled path template
 * @param {string} string A URL path template
 * @returns {PathTemplate} A compiled path template
 */
PathTemplate.add = function (template, string) {
  return addTemplate(template, PathTemplate.parse(string));
};

const range = function (start, end, exclusive) {
  const acc = [];
  for (let i = start; exclusive ? i < end : i <= end; i += 1) {
    acc.push(i);
  }
  return acc;
};

const zip = function (array, other) {
  const acc = [];
  for (let i = 0; i < array.length; i += 1) {
    acc.push([array[i], other[i]]);
  }
  return acc;
};

const subsectionIndexOf = function (array, other) {
  let aLength = array.length,
    oLength = other.length,
    diffrence = aLength - oLength,
    sections = zip(range(0, diffrence), range(oLength - 1, aLength, true)),
    start,
    end;
  for (let i = 0; i < sections.length; i += 1) {
    start = sections[i][0];
    end = sections[i][1];
    if (arrayEql(array.slice(start, end + 1), other)) {
      return sections[i];
    }
  }
};

const withoutTemplate = function (template, other) {
  let toRemove = subsectionIndexOf(template, other),
    start,
    end,
    result = template;
  if (toRemove) {
    start = template.slice(0, toRemove[0]);
    end = template.slice(toRemove[1] + 1);
    result = addTemplate(start, end);
  }
  return result;
};

/**
 * Returns a new path without the path segments described by string.
 *
 * @example
 * let photosTemplate = PathTemplate.without(photoTemplate, "/:photoID");
 *
 * @param {PathTemplate} template A compiled path template
 * @param {string} string A URL path template
 * @returns {PathTemplate} A compiled path template
 */
PathTemplate.without = function (template, string) {
  return withoutTemplate(template, PathTemplate.parse(string));
};
